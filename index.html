<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="https://www.w3.org/1999/xhtml">

<head>
    <title>ITensor - Intelligent Tensor Library</title>
    <meta http-equiv="content-language" content="en" />
    <meta http-equiv="content-type" content="text/html; charset=UTF-8" />
    <link rel="icon" href="favicon.ico"/>
    <link rel="stylesheet" href="style.css" type="text/css"/>
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.6/jquery.min.js" type="text/javascript"></script>
    <script type="text/javascript">$(document).ready(function(){});</script>
    <script type="text/javascript" src="scripts/jquery.corner.js"></script>
    <link rel="stylesheet" href="font-awesome/css/font-awesome.min.css">

    <style type="text/css">
    </style>

</head>

<body>

<div id="main">

<div id="navbar" class="rounded">
    <ul>
    <li><a class="thispage" href="index.html">Home</a> </li>
    <li><a href="news.html">News</a> </li>
    <li><a href="docs.cgi">Learn</a> </li>
    <li><a href="docs.cgi?page=codes">Codes</a> </li>
    <li><a href="support/">Discuss</a> </li>
    <li><a href="about.html">About ITensor</a></li>
    </ul>
</div>

<div id="banner">
<img src="ITensor.png"/></br>
</div>

<div class="full section rounded"> <h2>Introduction</h2> </div>

<div class="full">

    <div id="rightbar">

    <div id="download" class="rounded">
        <h4>
        Latest Julia version is <a href="docs.cgi?vers=julia&page=changelog#v0.2.3">v0.2.3</a>
        </h4>
        <h4>View source on <a target="_blank" href="https://github.com/ITensor/ITensors.jl">github&nbsp;<i style="color:#CD2626;" class="fa fa-external-link" aria-hidden="true"></i></a></h4>
        <h4>
        <a target="_blank" href="https://itensor.github.io/ITensors.jl/stable">Documentation for the Julia version&nbsp;<i style="color:#CD2626;" class="fa fa-external-link" aria-hidden="true"></i></a>
        </h4>
        <br/>

        <h4>
        Latest C++ version is <a href="docs.cgi?vers=cppv3&page=changelog#v3.1.9">v3.1.9</a>
        </h4>
        <h4>Clone from <a href="http://www.itensor.org/docs.cgi?page=install&vers=cppv3">github</a> (preferred)</h4>
        <h4>Download: <a href="https://github.com/ITensor/ITensor/tarball/v3.1.9">tar.gz</a> or
                     <a href="https://github.com/ITensor/ITensor/zipball/v3.1.9">zip</a> </h4>
        <br/>
        
        <h4>On Twitter<img width="30px" style="vertical-align:middle;" src="Twitter_Logo_Blue.png"/><a href="https://twitter.com/ITensorLib" target="_blank">@ITensorLib</a></h4>
        <h4><a href="email.html">Sign up</a> for email newsletters</h4>
    </div>

    <div id="latest" class="rounded">
        <a href="news.html"><h2 class="rounded">Recent News</h2></a>
        <ul>
        <li><a href="news.html#ITensorPaper">The ITensor Paper</a></li>
        <li><a href="news.html#Julia">Julia Version Released</a></li>
        <li><a href="news.html#v3.1">Version 3.1 Released</a></li>
        </ul>
        <br/>
    </div>

    </div> <!-- rightbar -->

    <p>
    ITensor&mdash;Intelligent Tensor&mdash;is a library for implementing 
    tensor network calculations. See the <a href="docs.cgi?page=papers">list of recent papers using ITensor</a>.
    <br/>Features include:
    <ul id="features">
    <li>Permuting indices is handled automatically when adding or contracting tensors</li>
    <li>Full-featured <a href="https://itensor.github.io/ITensors.jl/stable/MPSandMPO.html">matrix product state / tensor train</a> and <a href="http://itensor.org/docs.cgi?vers=julia&page=getting_started/dmrg">DMRG</a> layer</li>
    <li>Quantum number conserving (block-sparse) tensors; same interface as dense tensors</li>
    <li>Complex numbers handled automatically and efficiently</li>
    <li><a href="http://itensor.org/docs.cgi?vers=julia&page=getting_started/installing">Easy to install</a>, with a friendly and productive interface</li>
    <li>Multi-threaded contraction over sparse tensor blocks</li>
    <li>Automatically convert sums of local operators to MPOs (AutoMPO)</li>
    <li>Efficiently <a href="http://itensor.org/docs.cgi?vers=julia&page=getting_started/mps_time_evolution">apply local operators to MPS</a> (quantum circuits, time evolution)</li>
    </ul>
    </p>

    <p>
    ITensors have an interface resembling <a href="https://tensornetwork.org/diagrams/" target="_blank">tensor diagram notation</a>, making them nearly as easy to multiply as 
    scalars: tensors indices have unique identities
    and matching indices automatically contract when two ITensors are multiplied. 
    This type of interface makes it simple to transcribe tensor network diagrams into correct, efficient code.
    </p>
    <p>
    For example, the diagram below (resembling the overlap of matrix product states) 
    can be converted to code as
    </p>
    <img class="diagram" style="margin-left:100px;" width="400px" src="Diagram.png"/></br>
    <p>
    <b>Installing ITensor (Julia Version):</b>
    <ol>
        <li><a href="https://julialang.org/downloads" target="_blank">Install the Julia language</a>&nbsp;&nbsp;<i style="color:#336699;" class="fa fa-external-link" aria-hidden="true"></i></li>
        <li>Enter the command <code>julia</code> to start an interactive Julia session</li>
        <li>Inside this session, type <code>]</code> to enter the package manager</li>
        <li>Enter the command <code>add ITensors</code></li>
        <li> [Optional but Recommended] Enter the command <code>using ITensors; ITensors.compile()</code></li>
        <li>For more details, see our <a href="docs.cgi?vers=julia&page=getting_started/installing">installation guide</a> and read about <a href="docs.cgi?vers=julia&page=getting_started">getting started</a> with ITensor.</li>
    </ol>
    <p>Browse the in-depth <a href="https://itensor.github.io/ITensors.jl/stable">documentation pages for the Julia version</a> to learn more.</p>
    <p>Note that you can use Julia ITensor on a supercomputing cluster even if Julia is not installed system-wide.
    To do so, just <a href="docs.cgi?vers=julia&page=getting_started/cluster">install Julia locally</a> into your personal account.</p>
    </p>
    <br/>
    <p>
    <b>Installing ITensor (C++ version):</b>
    <ol>
    <li>Make sure you have an up-to-date C++17 compiler and LAPACK installed. On UNIX systems, use your
    package manager; on Mac OS install the free Xcode app from the app store;
    for Windows install <a href="https://www.cygwin.com" target="_blank">cygwin</a>.</li>
    <li>Clone the latest version of ITensor: <pre><code>git clone https://github.com/ITensor/ITensor itensor</code></pre>
        (Or <a href="https://github.com/ITensor/ITensor/archive/v3.zip" target="_blank">download</a> the zip file if you do not have git.)<br/>
        Cloning with <a href="http://git-scm.com" target="_blank">git</a> allows you to track changes to ITensor and is the preferred method; for more see our <a href="docs.cgi?vers=cppv3&page=tutorials/git">git quick start</a> guide.

    </li>
    <li>Create the options.mk file: <code>cp options.mk.sample options.mk</code>.
        Follow the instructions in this file to customize for your machine.
    </li>
    <li>Type <code>make</code> to build ITensor.</li>
    <li>The compiled library files remain inside the ITensor source
        folder and are not put anywhere else on your machine. To create a program using
        ITensor, use the files in the "tutorial/project_template" folder 
        as a starting point for making your own code.</li>
    </ol>
    </p>
    <p>
    For more details, read the full <a href="docs.cgi?page=install&vers=cppv3">installation</a> instructions.</br>
    Browse the <a href="docs.cgi?page=main&vers=cppv3">documentation pages for the C++ version</a> to learn more about ITensor.
    </p>
    
    <br/>
    <p>
    <b>Citing ITensor</b>
    <p>
    Please cite the <a href="https://arxiv.org/abs/2007.14822">ITensor paper</a> if you use the C++ or Julia version to produce data or other results for a publication.
    You may use the following BibTex entry to cite in LaTeX documents:
    <div class="full screenshot" style="font-family:monospace;">
        @misc{itensor,<br/>
        title={The \mbox{ITensor} Software Library for Tensor Network Calculations},<br/>
        author={Matthew Fishman and Steven R. White and E. Miles Stoudenmire},<br/>
        year={2020},<br/>
        eprint={2007.14822},<br/>
        archivePrefix={arXiv}<br/>
        }<br/>
    </div>
    </p>
    </p>



    </p>

<table id="people" style="border-collapse: collapse; border-spacing: 10px;">
<tr>
    <td>
    <p>
    We are grateful for ongoing support from the Simons Foundation.
    </p>
    </td>
    <td>
    <img width="400px" style="margin-left: 40px;" src="simons_found_logo.jpg"/>
    </td>
</tr>
<tr>
    <td>
    <p>
    ITensor was initiated with generous support from the United States Department of Energy.
    </p>
    </td>
    <td>
    <img height="100px" style="margin-left: 40px;" src="doe.png"/>
    </td>
</tr>
</table>
<br/>


<div class="full section rounded"> <h2>Code Samples &nbsp;&nbsp;(Julia Version)</h2> </div>

<div class="full screenshot">
<img src="MatrixDiagram.png" width="400px" style="float: right; margin-top:55px;"/>
<h2>Contract Two Matrix-Like ITensors</h2>
<pre>
using ITensors

a = Index(2)
b = Index(2) 
c = Index(2)

Z = ITensor(a,b)
X = ITensor(c,b)

Z[a=>1,b=>1] =  1.0
Z[a=>2,b=>2] = -1.0

X[b=>1,c=>2] = 1.0
X[b=>2,c=>1] = 1.0

<div style="color:#5081AA">
# The * operator finds and
# contracts common index 'b'
# regardless of index order:
</div>
R = Z * X

@show R[a=>2,c=>1]
<div style="color:#5081AA"># Output:
# R[a=>2,c=>1] = -1
</div>
</pre>
</div>



<div class="full screenshot">
<img src="TensorDiagram.png" width="400px" style="float: right; margin-top:55px;"/>
<h2>Contract and Add ITensors</h2>
<pre>
i = Index(3)
j = Index(5)
k = Index(2)
l = Index(7)

A = ITensor(i,j,k)
B = ITensor(l,j)

A[i=>1,j=>1,k=>1] = 11.1
A[i=>2,j=>1,k=>2] = -21.2
A[k=>1,i=>3,j=>1] = 31.1
A[k=>1,i=>1,j=>2] = 11.2

B[j=>2,l=>4] = 2+4im

C = A * B;
@show C

D = randomITensor(k,j,i)

R = A + D
</pre>
</div>



<div class="full screenshot">
<img src="SVDDiagram.png" width="400px" style="float: right; margin-top:55px;"/>
<h2>Factorize an ITensor (Using SVD)</h2>
<pre>

i = Index(3,"i")
j = Index(7,"j")
k = Index(2,"k")
l = Index(4,"l")

T = randomITensor(i,j,k,l)

U,S,V = svd(T,i,k)

@show norm(T - U*S*V)
<div style="color:#5081AA">
# Output: 
# norm(T - U*S*V) = 4.7458E-14
</div>

</pre>
</div>

<div class="full screenshot">
<h2>Perform a DMRG Calculation</h2>
<p>
DMRG is a powerful algorithm for finding dominant eigenvectors
of exponentially large matrices (such as quantum Hamiltonians) in matrix product 
state (MPS) form. It is adaptive and converges very quickly and to high precision.
</p>
<p>
In addition to state-of-the-art DMRG codes, ITensor features the AutoMPO system,
which is a powerful domain-specific language for creating matrix product operator (MPO)
tensor networks as a sum of local terms, which is especially useful for quantum mechanics
applications.
</p>
<br/>
<pre>
<span style="color:#5081AA"># Define Hilbert space of N spin-one sites</span>
N = 100
sites = siteinds("S=1",N; conserve_qns=true)

<span style="color:#5081AA"># Create 1d Heisenberg Hamiltonian</span>
ampo = AutoMPO()
for j = 1:N-1
  ampo += 1/2,"S+",j,"S-",j+1
  ampo += 1/2,"S-",j,"S+",j+1
  ampo +=     "Sz",j,"Sz",j+1
end

H = MPO(ampo,sites)

<span style="color:#5081AA"># Choose initial wavefunction</span>
<span style="color:#5081AA"># to be a product state</span>
psi0 = productMPS(sites,n->isodd(n) ? "Up" : "Dn")

<span style="color:#5081AA"># Perform 5 sweeps of DMRG</span>
sweeps = Sweeps(5)
<span style="color:#5081AA"># Specify max number of states kept each sweep</span>
setmaxdim!(sweeps,50,50,100,100,200)

<span style="color:#5081AA"># Run the DMRG algorithm</span>
energy,psi = dmrg(H,psi0,sweeps)

<span style="color:#5081AA"># Continue to analyze wavefunction afterward </span>
@show inner(psi,H,psi) <span style="color:#5081AA"># &lt;psi|H|psi&gt;</span>

<span style="color:#5081AA"># Measure "Sz" operator on every site </span>
sz = expect(psi,"Sz")
for j=1:N
  println("Sz_$j = ",sz[j])
end

</pre>
</div>


<!-- End Code Samples (Julia Version) -->

<div class="full">
<br/>
<br/>
<br/>
<br/>
<br/>
</div>

<!-- Begin Code Samples (Julia Version) -->

<div class="full section rounded"> <h2>Code Samples &nbsp;&nbsp;(C++ Version)</h2> </div>

<div class="full screenshot">
<img src="MatrixDiagram.png" width="400px" style="float: right; margin-top:55px;"/>
<h2>Contract Two Matrix-Like ITensors</h2>
<pre>
<span style="color:green">auto</span> a = Index(2), 
<span style="color:green">auto</span> b = Index(2), 
<span style="color:green">auto</span> c = Index(2);

<span style="color:green">auto</span> Z = ITensor(a,b), 
<span style="color:green">auto</span> X = ITensor(c,b);

Z.set(a=1,b=1, +1.0);
Z.set(a=2,b=2, -1.0);

X.set(b=1,c=2, +1.0);
X.set(b=2,c=1, +1.0);
<div style="color:#5081AA">
//the * operator finds and
//contracts common index 'b'
//regardless of index order:
</div>
ITensor R = Z * X;

Print( elt(R,a=2,c=1) ); 
<div style="color:#5081AA">
//output:
// elt(R,a=2,c=1) = -1
</div>
</pre>
</div>

<div class="full screenshot">
<img src="TensorDiagram.png" width="400px" style="float: right; margin-top:55px;"/>
<h2>Contract and Add ITensors</h2>
<pre>
<span style="color:green">auto</span> i = Index(3);
<span style="color:green">auto</span> j = Index(5);
<span style="color:green">auto</span> k = Index(2);
<span style="color:green">auto</span> l = Index(7);

<span style="color:green">auto</span> A = ITensor(i,j,k);
<span style="color:green">auto</span> B = ITensor(l,j);

A.set(i=1,j=1,k=1, 11.1);
A.set(i=2,j=1,k=2, -21.2);
A.set(k=1,i=3,j=1, 31.1);
A.set(k=1,i=1,j=2, 11.2);

B.set(j=2,l=4, 2.+4._i);

<span style="color:green">auto</span> C = A * B;
PrintData(C);

<span style="color:green">auto</span> D = randomITensor(k,j,i);

<span style="color:green">auto</span> R = A + D;
</pre>
</div>

<div class="full screenshot">
<img src="SVDDiagram.png" width="400px" style="float: right; margin-top:55px;"/>
<h2>Factorize an ITensor (Using SVD)</h2>
<pre>

<span style="color:green">auto</span> i = Index(3,"i");
<span style="color:green">auto</span> j = Index(7,"j");
<span style="color:green">auto</span> k = Index(2,"k");
<span style="color:green">auto</span> l = Index(4,"l");

<span style="color:green">auto</span> T = randomITensor(i,j,k,l);

<span style="color:green">auto</span> [U,S,V] = svd(T,i,k);

Print(norm(T - U*S*V));
<div style="color:#5081AA">
//output: 
// norm(T - U*S*V) = 4.7458E-14
</div>

</pre>
</div>

<div class="full screenshot">
<h2>Perform a DMRG Calculation</h2>
<p>
DMRG is a powerful algorithm for finding dominant eigenvectors
of exponentially large matrices (such as quantum Hamiltonians) in matrix product 
state (MPS) form. It is adaptive and converges very quickly and to high precision.
</p>
<p>
In addition to state-of-the-art DMRG codes, ITensor features the AutoMPO system,
which is a powerful domain-specific language for creating matrix product operator (MPO)
tensor networks as a sum of local terms, which is especially useful for quantum mechanics
applications.
</p>
<br/>
<pre>
<span style="color:#5081AA">//Define Hilbert space of N spin-one sites</span>
<span style="color:green">int</span> N = 100;
<span style="color:green">auto</span> sites = SpinOne(N);

<span style="color:#5081AA">//Create 1d Heisenberg Hamiltonian</span>
<span style="color:green">auto</span> ampo = AutoMPO(sites);
for(<span style="color:green">int</span> j = 1; j < N; ++j)
    {
    ampo += 0.5,"S+",j,"S-",j+1;
    ampo += 0.5,"S-",j,"S+",j+1;
    ampo +=     "Sz",j,"Sz",j+1;
    }
<span style="color:green">auto</span> H = toMPO(ampo);

<span style="color:#5081AA">//Choose initial wavefunction</span>
<span style="color:#5081AA">//to be a product state</span>
<span style="color:green">auto</span> psi0 = MPS(InitState(sites,"Z0"));

<span style="color:#5081AA">//Perform 5 sweeps of DMRG</span>
<span style="color:green">auto</span> sweeps = Sweeps(5);
<span style="color:#5081AA">//Specify max number of states kept each sweep</span>
sweeps.maxdim() = 50, 50, 100, 100, 200;

<span style="color:#5081AA">//Run the DMRG algorithm</span>
<span style="color:green">auto</span> [energy,psi] = dmrg(H,psi0,sweeps,"Quiet");

<span style="color:#5081AA">//Continue to analyze wavefunction afterward </span>
Print(inner(psi,H,psi)); <span style="color:#5081AA">//&lt;psi|H|psi&gt;</span>

for(<span style="color:green">int</span> j = 1; j &lt;= N; ++j)
    {
    <span style="color:#5081AA">//Make site j the MPS "orthogonality center"</span>
    psi.position(j);
    <span style="color:#5081AA">//Measure magnetization on site j</span>
    Real Szj = elt(psi(j)
               * op(sites,"Sz",j)
               * dag(prime(psi(j),"Site")));
    println("Sz_",j," = ",Szj);
    }
</pre>
</div>

<br/>


</div> <!--class full-->


<div id="footer"></div>

</div> <!--id="main"-->

<script type="text/javascript">
    $(function() {$('.rounded').corner("7px");});
</script>

</body>
</html>
